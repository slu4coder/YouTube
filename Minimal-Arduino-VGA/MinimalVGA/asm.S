#define __SFR_OFFSET 0x00   		// set the Special Function Register Offset from 0x20 to 0x00 in order to use the AVR PORT definitions
#include <avr/io.h>         		// include PORTB, DDRD, ... symbols for easier register access

.global TIMER0_COMPA_vect       ; define this global to make the Arduino IDE integrate the ISR

.macro ONECHAR              		; Z: address of char data (MSB is fixed, LSB depends on char), X: current VRAM position (one line)
            ld    ZL, X+        ; 2   ZL = (X), X = X + 1
            lpm   r21, Z        ; 3   get font byte from program memory for current chr on current line
            out   PORTD, r21    ; 1   put data to shift register
            out   PORTB, r19    ; 1   /PE LOW (next CLOCK will load pixel data)
            out   PORTB, r18    ; 1   /PE HIGH (now CLOCK will pump out the pixels)
 .endm

; *******************************************************************
; *****                                                         *****
; ***** Assembler routine sending out pixel data for a scanline *****
; *****                                                         *****
; *******************************************************************
TIMER0_COMPA_vect:              ; ISR table entry is automatically generated by the AVR assembler
            push r1             ; save r1 and r0 (the compiler needs this)
            push r0
            in r0, SREG         ; reads the AVR status register SREG 0x3f holding the complete flag state
            push r0             ; push it on the stack, too
            eor r1, r1          ; r1: 0

            push  r18           ; save content, so we can use it

            lds r18, TCNT2      ; timer TCNT2 jitter compensation
            cpi r18, 4
            breq .+8
            cpi r18, 3
            breq .+6
            cpi r18, 2
            breq .+4
            nop
            nop
            nop

            cbi PORTB, 4        ; start of sync pulse

            push  r19
            push  r20
            push  r21
            push  r22
            push  r23
            push  r24
            push  r25
            push  r26
            push  r27
            push  r30
            push  r31

            lds r20, vline      ; load vline to r20-21
            lds r21, vline+1
            movw r24, r20       ; copy register pair
            adiw r24, 1         ; increment vline by 1
            sts vline+1, r25    ; store vline
            sts vline, r24
            asr r21             ; divide vline by 2 and subtract 30
            ror r20
            subi r20, 30        ; r20: pixel line "lin"

            sbi PORTB, 4        ; end of sync pulse (after 2,5µ, should be 3,8µs but this buys valuable time here)

            mov r21, r20        ; calculate VRAM row address from lin
            lsr r21
            lsr r21
            lsr r21             ; lin>>3

            ldi r25, 40
            mul r25, r21        ; calculate * 40 => result is in r0-1
            movw r30, r0        ; r30-31 (Z): index of VRAM row
            eor r1, r1          ; r1: 0
            
            ldi XL, lo8(vram)
            ldi XH, hi8(vram)
            add XH, ZH          ; add VRAM row index to VRAM start address
            add XL, ZL
            adc XH, r1          ; r26-27 (X): VRAM row address

            mov r21, r20        ; get lin
            andi r21, 7         ; only use lowest 3 bits of lin to determin charset line

            ldi ZH, hi8(charset); charset must be aligned to 256 bytes
            add ZH, r21         ; ZH: MSB of charset line address

            ldi r18, 0x18       ; different /PE states
            ldi r19, 0x10

            cpi r20, 200        
            brcs drawPixels
              jmp regHandler

drawPixels: ldi r21, 20           ; shifts screen left BUT BE CAREFUL: if routine takes too long, it won't fit into a scanline!
wait:       dec r21
            brne wait

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
               
regHandler: pop r31
            pop r30
            pop r27
            pop r26
            pop r25
            pop r24
            pop r23
            pop r22
            pop r21
            pop r20
            pop r19
            pop r18
            pop r0        ; restore the AVR status register SREG 0x3f value
            out SREG, r0  ; set the SREG back to what it was
            pop r0        ; restore r0, r1 
            pop r1
            reti          ; return from interrupt
